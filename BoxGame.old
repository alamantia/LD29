/* Why isn't this a class? */
#ifdef ANDROID
#include <android/log.h>
#endif

#include <iostream>
#include <string>
#include <list>
#include <map>
#include <algorithm>
#include <functional>

#include "BoxGame.h"
#include "Button.h"
#include "simplexnoise.h"
#include "defines.h"
#include "Drop.h"
#include "Context.h"
#include "Camera.h"
#include "Clouds.h"
#include "P1.h"

using namespace std;

extern  int   game_mode;
extern  float box_height;
extern  float box_width;
extern  float UNIT_HEIGHT;
extern  float UNIT_WIDTH;

// used for detecting the possible toggle states

extern int SCREEN_WIDTH;
extern int SCREEN_HEIGHT;

extern int WINDOW_WIDTH;
extern int WINDOW_HEIGHT;

Clock *_clock;
extern Window *_window;
extern Audio  *_audio;
extern Camera *_camera;
extern Texture *_texture;
extern SDL_Renderer *renderer;

int tiles_wide = BOX_WIDTH;
int tiles_tall = BOX_HEIGHT;

int tile_width  = 32;
int tile_height = 32;

bool paused = false;
typedef  Thing * tile;

struct position_rect {
  int x;
  int y;
};

tile **tiles;
Thing  *Player;
Thing  *activeBlock = nullptr;
Clouds *clouds;

list<tile> gameObjects;
list<P1 *> P1s;

// rather then making the player a different entitiy .. just do it here
// move anything handy to the thing class.

enum {
  MOVING_NONE,
  MOVING_RIGHT,
  MOVING_LEFT,
};

bool is_jumping = false;
int  is_moving  = MOVING_NONE;

AVector2D *pFacing    = new AVector2D(0.0, 0.0);
AVector2D *pDirection = new AVector2D(0.0, 0.0);

void player_callback(void *t, int type, string message)
{
  printf("Got player callback\n");
  if (type == TWEEN_LINEAR) {
    printf("--- checking if there is a need tween node\n");
  }
  return;
}

void b_callback(void *t, int type, string message)
{
  printf("Got callback %s\n", message.c_str());
  return;
}

Thing * getBox(int x, int y)
{
  return tiles[x][y];
}

void  destory_block(Thing *t, int x, int y) 
{
  gameObjects.remove(tiles[x][y]);
  tiles[x][y] = nullptr;
  gameObjects.remove(t);
  add_p1(t->x, t->y);
  _camera->Shake(100.0); 

  return;
}

void  map_remove(unsigned int **m) 
{
  int m_count = 0;
  for (int i = 0; i < tiles_wide; i++) {
    for (int j = 0; j < tiles_tall; j++) {
      if (m[i][j] == 1) {
        m_count++;
      }
    }
  }
  if (m_count < 3) 
    return;
  printf("\n found a matching group (%i total)\n", m_count);
  for (int i = 0; i < tiles_wide; i++) {
    for (int j = 0; j < tiles_tall; j++) {
      if (m[i][j] == 1) {
        Thing *t = tiles[i][j];
        printf("Match (%i) (%i, %i)\n", t->c, i, j);
        destory_block(t, i, j); 
      }
    }
  }
  for (int i = 0; i < tiles_wide; i++) {
    for (int j = 0; j < tiles_tall; j++) {
      tiles[i][j] = nullptr;
    }
  }
  return;
}

// detect a clicked tile
void click_x_y(int x, int y)
{
  return;
}

// find the max hight for a column
// will be used for the one handed gameplay
int max_column_height(int column)
{

  return 0;
}


//tile **tiles; 
void *map_match(unsigned int **m, int type, int x, int y)
{
  int c_x = x;
  int c_y = y;

  Thing *tC = tiles[x][y];
  
  Thing *tR = nullptr;
  Thing *tL = nullptr;
  Thing *tU = nullptr;
  Thing *tD = nullptr;
  
  if (tC->c == type) {
    m[x][y] = 1;
  }

  if (c_x > 0) {
    if ((tL = tiles[x-1][y]) != nullptr) {
      if (tL->c == type) {
      }  
    }
  }

  if (c_y > 0) {
    if ((tD = tiles[x][y-1]) != nullptr) {  
      if (tD->c == type) {
      }
    }
  }
  
  if (c_x < tiles_wide) {
    if ((tR = tiles[x+1][y]) != nullptr) {
      if (tR->c == type) {
      }
    }
  }

  if (c_y < tiles_tall) {
    if ((tU = tiles[x][y+1]) != nullptr) {
      if (tU->c == type) {
      }
    }
  }
  // termination condition
  return nullptr;
}

// more limited matching, vertical and horizontal only
void *map_match_2(unsigned int **m, int type, int x, int y)
{
  Thing *tc = tiles[x][y];
  for (int i = y; i > 0; i--) {
    Thing *t = tiles[x][i];
    if (t == nullptr) 
      break;
    if (t->c != type)
      break;
    m[x][i] = 1;
  }
  
  for (int i = y; i < tiles_tall; i++) {
    Thing *t = tiles[x][i];
    if (t == nullptr) 
      break;
    if (t->c != type)
      break;
    m[x][i] = 1;
  }
  
  for (int i = x; i < tiles_wide; i++) {
    Thing *t = tiles[i][y];
    if (t == nullptr)
      break;
    if (t->c != type) {
      break;
    }
    m[i][y] = 1;
  }
  for (int i = x; i > 0; i--) {
    Thing *t = tiles[i][y];
    if (t == nullptr) {
      break;
   }
    if (t->c != type)
      break;
    m[i][y] = 1; 
  } 
  return nullptr;
}

void perform_matching()
{  
  unsigned int sz =  (tiles_wide * 2) * (tiles_tall * 2) * sizeof (unsigned int);
  unsigned int **m = new unsigned int*[tiles_wide*2];
  for (int i = 0; i < tiles_wide * 2; ++i) {
    m[i] = new unsigned int[tiles_tall*2];
  } 
  for (int y = 0; y < tiles_tall; y++) {
    for (int x = 0; x < tiles_wide; x++) {
      if (tiles[x][y] == nullptr)
        continue;
      for (int i = 0; i < tiles_wide * 2; i++) {
        for (int j = 0; j < tiles_tall * 2; j++) {
          m[i][j] = 0;
        }
      }
      Thing *t = tiles[x][y];
      if (t->c == 666)
        continue;
      map_match_2(m, tiles[x][y]->c, x, y);
      map_remove(m);
    }
  }
  for (int i = 0; i < tiles_wide * 2; ++i) {
    delete m[i];
  }
  delete m;
  return;
}

struct position_rect grid_position_point(int x, int y)
{
  struct position_rect r;
  r.x = 0;
  r.y = 0;

  float box_grid_x  = 0;
  float box_grid_y  = 0;
  
  box_grid_x = (float)x / (float)(tile_width);
  box_grid_y = (float) y / (float)(tile_height);
 
  printf("%f %f for %i %i\n", box_grid_x, box_grid_y, tile_width, tile_height);
  box_grid_x = floor(box_grid_x );
  box_grid_y = floor(box_grid_y );
 
 printf("%f %f for %i %i\n", box_grid_x, box_grid_y, tile_width, tile_height);
  
  r.x = (int) box_grid_x;
  r.y = (int) box_grid_y;

  return r;
}

// compute the grid position of a tile
struct position_rect grid_position(Thing *tile) 
{
  struct position_rect r;
  r.x = 0;
  r.y = 0;
  

  float box_grid_x  = 0;
  float box_grid_y  = 0;
  
  if ( (tile->x + (tile->w/2)) < tile_width) {
    box_grid_x = 0;
  } else {
    box_grid_x = (tile->x + (tile->w/2)) / tile_width;
  }
  
  if (tile->y < tile_height) {
    box_grid_y = 0;
  } else {
    box_grid_y = tile->y / tile_height;
  }
  
  box_grid_x = floor(box_grid_x);
  box_grid_y = floor(box_grid_y);
  
  r.x = (int) box_grid_x;
  r.y = (int) box_grid_y;

  return r;
}

void move_activate() 
{
  // add_p1(SCREEN_WIDTH/2, SCREEN_HEIGHT/2);
  if (activeBlock != nullptr) {
    struct position_rect r = grid_position(activeBlock);
    activeBlock->x = r.x * tile_width;
    activeBlock = nullptr;
    //_camera->Shake(0.05);
    return;
  }
  printf("Activation\n");
  struct position_rect pos = grid_position(Player);
  if(pos.y == 11)
    return;

  pos.y = pos.y  + 1;
  Thing *t = tiles[(int)pos.x][(int)pos.y];
  if (t == nullptr) {
    printf("Nothing to activate\n");
    return;
  }
  if (t->c == 666)
    return;
  activeBlock = t;
  tiles[(int)pos.x][(int)pos.y] = nullptr;
  
  for (int x = 0; x <  BOX_WIDTH; x++) {
    for (int y = 0; y < BOX_HEIGHT; y++) {
      if (tiles[x][y] == activeBlock) {
	      tiles[x][y] == nullptr;
      }
    }
  }
  
  printf("We have something to activate\n");

  
  return;
}

void move_stop() 
{
  pDirection->x = 0.0;
  is_moving = MOVING_NONE;
}

void move_left()
{
  printf("Move left\n");
  is_moving = MOVING_LEFT;
  pDirection->x = -2.0;
  return;
}

void move_right()
{
  printf("Move right\n");
  is_moving = MOVING_RIGHT;
  pDirection->x = 2.0;
  return;
}

void move_jump()
{
  if (is_jumping == true) {
    return;
  }
  printf("Jump!\n");
  pDirection->y = -9.0;
  is_jumping = true;
  return;
}

void add_p1(int x, int y) 
{
  P1 *p1 = new P1(x,y);
  p1->event_callback = &b_callback;
  P1s.push_back(p1); 
  _camera->Shake(1.0);
  return;
}

/* compute the path to the point we would like to interpolate towards */
class PathNode {
  public:
    int sequence;
    bool visit;
    int x;
    int y;
};

int node_cost(PathNode *cNode, PathNode *dNode)
{
  int cost = 0;
  cost = ((cNode->x - dNode->x) * (cNode->y - dNode->y));
  return cost;
}

// just use euclidean distance.
int compute_cost(struct position_rect *c, struct position_rect *t)
{
  int d = -100;
  d = floor(sqrt(pow((t->x - c->x), 2) + pow((t->y - c->y),2))); 
  return d;
}

void move_to_point(int x, int y)
{
  list <PathNode *> path;
 
  struct position_rect tP;
  struct position_rect pP;
  struct position_rect nP;
  struct position_rect costPosition;
 
  tP =  grid_position_point(x, y);
  pP =  grid_position(Player);

  //tP.y = tP.y + 1;
  printf("Camera %i %i\n", _camera->x, _camera->y);
  printf("target grid position %i,%i\n", tP.x, tP.y);
  printf("player grid position %i,%i\n", pP.x, pP.y);

  nP.x = pP.x;
  nP.y = pP.y;
  
  // http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html#S7
  for (;;) {
    AVector2D *dist = new AVector2D(nP.x - tP.x, nP.y - tP.y);

    if (nP.x == tP.x && nP.y == tP.y) { 
      printf("\t-- path found\n");
      return; 
    }

    printf("-- distance (%i,%i)\n", dist->x, dist->y);

    int cU = 1000;
    int cD = 1000;
    int cL = 1000;
    int cR = 1000;

    if (pP.y > 0) {
      costPosition.x = pP.x;
      costPosition.y = pP.y - 1;
      cU = compute_cost(&costPosition, &tP);
    }

    if (pP.y < tiles_tall) {
      costPosition.x = pP.x;
      costPosition.y = pP.y + 1;
      cD = compute_cost(&costPosition, &tP);
    }

    if (pP.x > 0) {
      costPosition.x = pP.x - 1;
      costPosition.y = pP.y;
      cL = compute_cost(&costPosition, &tP);
    }

    if (pP.x < tiles_wide) {
      costPosition.x = pP.x + 1;
      costPosition.y = pP.y;
      cR = compute_cost(&costPosition, &tP);
    }
    
    printf("Cost Up\t%i\n",    cU);
    printf("Cost Down\t%i\n",  cD);
    printf("Cost Left\t%i\n",  cL);
    printf("Cost Right\t%i\n", cR);
 
    Player->MoveTo( (tP.x * tile_width) ,  (tP.y * tile_height), 100);
    return;
    exit(0);
  }
  
  printf("\n\n-- dumping desired path\n");  
  
  for (auto it = path.begin(); it != path.end(); ++it) {
    PathNode *node = *it;
    printf("\t Node -%i- (%i,%i)\n", node->sequence, node->x, node->y); 
  }
}

void handle_event(SDL_Event e)
{
  if (e.type == SDL_KEYDOWN) {
    int keycode = e.key.keysym.sym;
    switch (keycode) {
    case SDLK_SPACE: {
      move_activate();
      break;
    }
    case SDLK_p: {
      paused = !paused;
    }
    case SDLK_RIGHT: {
      move_right();
      break;
    }
    case SDLK_LEFT: {
      move_left();
      break;
    }
    case SDLK_UP: {
      move_jump();
      break;
    }
    default:
      break;
    }
  }
  if (e.type == SDL_KEYUP) {
    int keycode = e.key.keysym.sym;
    switch (keycode) {
    case SDLK_RIGHT:
    case SDLK_LEFT: {
      pDirection->x = 0.0;
      is_moving = MOVING_NONE;
      break;
    }
    case SDLK_UP: {
      break;
    }
    default:
      break;
    }
  }
   // mouse movement for now e.x and e.y are our keys here.
   // we want to use seperate handlers for touch events.
   SDL_MouseButtonEvent me = e.button;
   if (e.type == SDL_MOUSEBUTTONDOWN) {
    if (me.button == SDL_BUTTON_LEFT) {        
      printf("Click at %i,%i\n", me.x, me.y);
      // we need to convert WINDOW position to screen POSITION first! 
      float y_real = (float)me.y / (float)(WINDOW_HEIGHT - 40);
      float y_screen = SCREEN_HEIGHT * y_real; 
      float x_real = (float) me.x / (float) WINDOW_WIDTH;
      float x_screen = SCREEN_WIDTH * x_real;
      move_to_point((int)floor(x_screen + 0.5), (int)floor(y_screen + 0.5));
    }
  }
  if (e.type == SDL_MOUSEBUTTONUP) {
    if (me.button == SDL_BUTTON_LEFT) {
    }
  }
  return;
}

void draw_background()
{
  SDL_Rect pos;

  pos.x = 0;
  pos.y = 0;
  pos.w = SCREEN_WIDTH;
  pos.h = SCREEN_HEIGHT;
   SDL_RenderFillRect(_window->renderer, &pos);
   
  float s_height = WINDOW_WIDTH / 6;
  
  float r = 195;
  float g = 244;
  float b = 244;
  
  SDL_SetRenderDrawColor(_window->renderer, r, g, b, 0);
  SDL_RenderFillRect(_window->renderer, &pos);
  return; 
  for (float s_y = 0; s_y < WINDOW_HEIGHT; s_y += s_height) {
    pos.x = 0;
    pos.y = s_y;
    pos.w = WINDOW_WIDTH;
    pos.h = s_height;
    SDL_RenderFillRect(_window->renderer, &pos);
  }
  return;
}

void setup_game() 
{
  _clock = new Clock();
  tile_width  =  SCREEN_WIDTH  / tiles_wide;
  tile_height =  SCREEN_HEIGHT / tiles_tall;  
  
  printf("Tiles (%i %i)\n", 
	 tile_width,
	 tile_height);
   
  tiles = new tile*[2048];
  for (int i = 0; i <= tiles_wide; i++) {
    tiles[i] = new tile[2048];
  }
  
  for (int y = 0; y <= tiles_tall; y++) {
    for (int x = 0; x <= tiles_wide; x++) {
     tiles[x][y] = nullptr;
    }
  }
  
  Player = new Thing();
  Player->type = LOL_PLAYER;
  Player->x = 0;
  Player->y = tile_height * 11;
  Player->w = tile_width;
  Player->h = tile_height;
  Player->event_callback = &player_callback;

  printf("Want width %f %f\n", (float)Player->w, (float)Player->h);
 
  place_box_tile(4,11);
  place_brick(3,8);
  place_box_tile(2,2);
  
  activeBlock = nullptr;
  place_box_tile(7,10);
  place_brick(5,2);
  place_box_tile(4,4);
 
  clouds = new Clouds();
  return;
}


void match_blocks() 
{
  
}

void move_blocks()
{
  
  // check if tile below is occupied
  
  // if it's not .. we are in transit.
  // if it is we are not in transit .. set the grid position.
  
  return;

}

bool box_in_range(int x, int y)
{
  for (auto it = gameObjects.begin(); it != gameObjects.end(); ++it) {
    Thing *t = *it;
    if (t->contains_point(x,y)) {
      return true;
    } 
  } 
  return false;
}

void place_brick(int x, int y)
{
  Thing *box = new Thing();
  box->type = LOL_BOX;
  gameObjects.push_back(box);
  
  int p_x = tile_width  * x;
  int p_y = tile_height * y;
  
  box->x = p_x;
  box->y = p_y;
  box->w = tile_width;
  box->h = tile_height;

  box->c = 666;
  box->c_d = SDL_GetTicks();
  box->r_t = 1000;  
  return;
}

void place_box_tile(int x, int y) 
{
  int max_colors = 2;
  Thing *box = new Thing();
  box->type = LOL_BOX;
  gameObjects.push_back(box);
  
  int p_x = tile_width  * x;
  int p_y = tile_height * y;
  
  printf("%i %i\n", p_x, p_y);
  
  box->x = p_x;
  box->y = p_y;
  box->w = tile_width;
  box->h = tile_height;

  box->c = rand() % max_colors;
  box->max_colors = max_colors;
  box->c_d = SDL_GetTicks();
  box->r_t = 1000;  
  return;
}

void place_box_tile(int x, int y, int max_colors) 
{
  if (box_in_range(x * tile_width, y * tile_height)) {
    return;
  }
  Thing *box = new Thing();
  box->type = LOL_BOX;
  gameObjects.push_back(box);
  
  //tiles[x][y] = box;
  
  int p_x = tile_width  * x;
  int p_y = tile_height * y;
  
  printf("%i %i\n", p_x, p_y);
  
  box->x = p_x;
  box->y = p_y;
  box->w = tile_width;
  box->h = tile_height;

  box->c = rand() % max_colors;
  box->max_colors = max_colors;
  box->c_d = SDL_GetTicks();
  box->r_t = 1000;  
 
  return;
}


void draw_active_box(Thing *box) 
{
  SDL_Rect rect;
  SDL_Texture *box_texture;
  rect.x = box->x;
  rect.y = box->y;
  rect.w  = box->w;
  rect.h  = box->h;
  char main_box[] = "box.png";  
  SDL_SetRenderDrawColor(_window->renderer, 255, 255, 255, 255);
  if (box->c == COLOR_1) {
    box_texture = _texture->GetTexture("box.png");
  } else if (box->c == COLOR_2) {
    box_texture = _texture->GetTexture("box2.png");
  } else if (box->c == COLOR_3) {
    box_texture = _texture->GetTexture("box3.png");
  } else if (box->c == COLOR_4) {
    box_texture = _texture->GetTexture("box4.png");
  }
  renderTexture(box_texture, _window->renderer,
		  POS_X(box->x),
		  POS_Y(box->y),
		  box->w, box->h);
  return;
}

void draw_box(Thing *box) 
{
  SDL_Rect rect;
  SDL_Texture *box_texture;
  rect.x = box->x;
  rect.y = box->y;
  rect.w  = box->w;
  rect.h  = box->h;
  char main_box[] = "box.png";  
  SDL_SetRenderDrawColor(_window->renderer, 255, 255, 255, 255);
  if (box->c == COLOR_1) {
    box_texture = _texture->GetTexture("box.png");
  } else if (box->c == COLOR_2) {
    box_texture = _texture->GetTexture("box2.png");
  } else if (box->c == COLOR_3) {
    box_texture = _texture->GetTexture("box3.png");
  } else if (box->c == COLOR_4) {
    box_texture = _texture->GetTexture("box4.png");
  } else if (box->c == 666) {
    box_texture = _texture->GetTexture("brick.png");
  }
  if (box == activeBlock) {
    return;
  }
  bool should_fall = false;
  // step one locate where in the gird the box generally is ...
  float box_grid_x  = 0;
  float box_grid_y  = 0;
  
  if (box->x < tile_width) {
    box_grid_x = 0;
  } else {
    box_grid_x = box->x / tile_width;
  }
  if (box->y < tile_height) {
    box_grid_y = 0;
  } else {
    box_grid_y = box->y / tile_height;
  }
  
  box_grid_x = floor(box_grid_x);
  box_grid_y = floor(box_grid_y);
  
  if (box_grid_y < tiles_tall-1) {
    if (tiles[(int)box_grid_x][(int)box_grid_y + 1] == nullptr) {
      should_fall = true;
    } else {
        box->x = (box_grid_x) * tile_width;
        box->y = (box_grid_y) * tile_height;
        if (  tiles[(int)box_grid_x][(int)box_grid_y] != box ) {
          //_camera->Shake(0.05);
        }
        tiles[(int)box_grid_x][(int)box_grid_y] = box;
    }
      renderTexture(box_texture, _window->renderer,
		  POS_X(box->x),
		  POS_Y(box->y),
		  box->w, box->h);
  } else {
    if (  tiles[(int)box_grid_x][11] != box ) {
         //_camera->Shake(0.05);
    }
    tiles[(int)box_grid_x][11] = box;
    renderTexture(box_texture, _window->renderer,
		  POS_X(box->x),
		  POS_Y((11 * tile_height)),
		  box->w, box->h);
  }
 if (should_fall == true) {
    box->y += 4;
  }
  return;
}

void move_player() 
{
  return;

  // compute the min/max y position for the current column
  // and iterpolate the position as required.
  // replace 11 with the proper row number
  int max_y = tile_height * 11;
  
  // find player x y location
  
  float box_grid_x  = 0;
  float box_grid_y  = 0;
  
  if ((Player->x + (Player->w/2)) < tile_width) {
    box_grid_x = 0;
  } else {
    box_grid_x = (Player->x + (Player->w/2)) / tile_width;
  }
  if (Player->y < tile_height) {
    box_grid_y = 0;
  } else {
    box_grid_y = Player->y / tile_height;
  }
  
  box_grid_x = floor(box_grid_x );
  box_grid_y = floor(box_grid_y );

  // find the correct max_y
  for (int y = box_grid_y; y <= 11; y++) {
    if (tiles[(int)box_grid_x][y] != nullptr) {
      max_y =  (tile_height * (y -1));
      break;
    }
  }
  
  Player->y += pDirection->y;  

  // degrade the  jumping velocity  
  pDirection->y += 0.25;
  if (pDirection->y > 5) {
    pDirection->y = 5;
  }

  // apply gravity (value is fixed based on max_y before the next draw takes place)
  Player->y += 4;
  
  // max is the bottom
  if (Player->y >= max_y) {
    Player->y = max_y;
    is_jumping = false;
  }

  float n_x = 0.0;
  if (pDirection->x < 0) {
    // moving left
    n_x =  floor( ( ( (Player->x - (Player->w/6)) + pDirection->x)/tile_width ) + 0.5);
  } else if (pDirection > 0) {
    // moving right
    n_x =  floor(  ((Player->x + (Player->w/6) + pDirection->x)/tile_width )+ 0.5);
  }
  if ((int)n_x >= 0) { // which box grid we are at.
    if ((int)n_x < BOX_WIDTH) {
      if (tiles[(int)n_x][(int)box_grid_y] == nullptr) {
        Player->x += pDirection->x;
      }
    }
  }
  if (activeBlock != nullptr) {
    activeBlock->x = Player->x;
    activeBlock->y = Player->y - (tile_height) + 5;
  }
  return;
}

void setup_player_animations() 
{
  return;
}

void draw_player()
{
  SDL_SetRenderDrawColor(_window->renderer, 200, 0, 0, 255); 
  SDL_RendererFlip flip = SDL_FLIP_NONE;
  flip = SDL_FLIP_HORIZONTAL;
  SDL_Texture *t = _texture->GetTexture("1.png");
  if (activeBlock != nullptr) {
    t = _texture->GetTexture("2.png");
    draw_active_box(activeBlock);
  }
  renderTexture(t, _window->renderer,
		POS_X(Player->x),
		POS_Y(Player->y),
		Player->w, Player->h );
    Player->Tick();
}

void render_game()
{
  SDL_RenderClear(_window->renderer);
  _window->BeginTextureRender();
  draw_background();
  clouds->Render(_window->renderer);
  for_each(gameObjects.begin(), gameObjects.end(), 
           [](Thing *thing) {				
	     if (thing->type == LOL_BOX) {
	       draw_box(thing);
	     }
	   });
  for (auto it = P1s.begin(); it != P1s.end();) {
    P1 *p1 = *it;
    if(!p1->Render(_window->renderer)) {
      it = P1s.erase(it);
      delete p1;
      continue; 
    } 
    ++it;
  } 
  draw_player();
  
  // we may want to disable some of these ..
  move_player();
  move_blocks();
  
  tick_game();
  _window->EndTextureRender();
  _camera->Tick();

  perform_matching();
  //if (!paused)
  //  drop_machine();
  _clock->Tick();

  return;
}

//tick the game simulation
void tick_game()
{
  return;
}

void log() {
  #ifdef ANDROID
  __android_log_write(ANDROID_LOG_INFO, "tag here", "message here");
  #endif
}
